* scala中所有数据类型都是类
* 类型推断机制：根据初始值自动推断变量的类型，使得定义变量时可以省略具体的数据类型及其前面的冒号
* 下划线 _ 用于导入所有成员，方便简化代码
* 字符串插值机制：` scala> println(s”$s:i=$i,f=$f”)`

![](image-20250105105427509.png)

![](image-20250105105433712.png)


* 有一点与Java不同的是，==Scala中的if表达式的返回值可以赋值给变量==
*  for( 变量 <- 表达式 ) {语句块}其中，“变量<-表达式”被称为“==生成器==（generator）”
* “守卫(guard)”的表达式。 for( 变量 <- 表达式 if 条件表达式 ) {语句块}
* •==for推导式==：for结构可以在每次执行的时候创造一个值，然后将包含了所有产生值的集合作为for循环表达式的结果返回，集合的类型由生成器中的集合类型确定

```
 for( 变量 <- 表达式 )  yield {语句块}

 scala> r = for( i <- Array(12,32,11,17,25,64) if i%2==0 ) yield { i }
```
* Scala没有break和continue关键字
* breakable类，==break跳到breakable外==

![](image-20250105105841436.png)

* 元组是对多个==不同类型对象==的一种简单封装。数组是相同类型的。
* ==使用下划线“`_`”加上从1开始的索引值，来访问元组的元素==

==索引方式区分不同容器==

* Seq使用从0开始的整数作为索引
* Set没有索引
* Map按照键索引

* 对于包括List在内的所有容器类型，如果没有显式指定元素类型，Scala会自动选择所有初始值的最近公共类型来作为元素的类型
* 链表实现：Scala 的 List 是通过递归定义的。每个 List 要么是空的（Nil），要么是一个包含头部元素（head）和一个尾部元素列表（tail）。==尾部（tail）本身也是一个 List==。
* 构造列表常用的方法是通过在已有列表前端增加元素，使用的操作符为::
![](image-20250105110425445.png)

* to和until
* range这里
* ![](image-20250105110521353.png)

映射
* ==键是唯一的，但值不一定是唯一的==。
* 好习惯，先contains
![](image-20250105110621275.png)

可变映射
![](image-20250105110643896.png)

==一个迭代器只能遍历一次==
![](image-20250105110728956.png)

面向对象的编程

类属性
* •Scala类中所有成员的默认可见性为公有，任何作用域内都能直接访问公有成员
* •除了默认的公有可见性，Scala也提供private和protected，其中，private成员只对本类型和嵌套类型可见；protected成员对本类型和其继承类型都可见
![](image-20250105110947578.png)


类方法
* ==•无参数的方法定义时可以省略括号，这时调用时也不能带有括号；如果定义时带有括号，则调用时可以带括号，也可以不带括号==
* •如果方法只有一个参数，可以省略点号（.）而采用==中缀操作符==调用方法
* •如果方法体只有一条语句，可以省略方法体两边的大括号
* •当方法的返回结果类型可以从最后的表达式推断出时，可以省略结果类型
* •==如果方法返回类型为Unit，可以同时省略返回结果类型和等号，但不能省略大括号==

* •没有同名类的单例对象，被称为孤立对象（standalone object）。一般情况下，Scala程序的入口点main方法就是定义在一个孤立对象里
* •apply方法调用约定：用括号传递给类实例或单例对象名一个或多个参数时，Scala 会在相应的类或对象中查找方法名为apply且参数列表与传入的参数一致的方法，并用传入的参数来调用该apply方法
* 与工厂模式的结合：在伴生对象的 apply 方法中，可以根据参数的不同返回不同的类的实例，从而实现工厂模式的功能，使得对象的创建更加灵活和可控。

```
值类型和引用类型是两种基本的数据类型，它们的主要区别在于如何存储和访问数据。

值类型（Value Type）

定义：值类型的变量直接存储数据的值。赋值时，变量的值被复制到另一个变量中。

存储：通常在栈（stack）中分配内存。

特点：

赋值时会创建数据的副本，两个变量互不影响。

性能较高，适合小型数据类型。

示例：在 Scala 中，基本数据类型如 Int、Double、Boolean 和 Char 都是值类型。

引用类型（Reference Type）

定义：引用类型的变量存储的是对象的引用（指针），而不是对象的实际数据。赋值时，变量存储的是指向对象的地址。

存储：通常在堆（heap）中分配内存。

特点：

赋值时复制的是对象的引用，多个变量可以引用同一个对象。

修改其中一个变量的对象内容会影响其他引用同一对象的变量。

示例：在 Scala 中，所有对象类型（如类实例、数组、集合等）都是引用类型。
```

* Scala的==特质是代码重用的基本单元==，可以同时拥有抽象方法和具体方法
* •Scala中，一个类只能继承自一个超类，却可以实现多个特质，从而重用特质中的方法和字段，实现了多重继承
* •case==后面的表达式可以是任何类型的常量，而不要求是整数类型==
* •match结构中不需要break语句来跳出判断，Scala从前往后匹配到一个分支后，会自动跳出判断
* ==除了匹配特定的常量，case还能匹配某种类型的所含有的值==

```scala
 

 for (elem <- List(6,9,0.618,"Spark","Hadoop",'Hello)){

   val str  = elem match  {

       case i: Int => i + " is an int value."//匹配整型的值，并赋值给i

       case d: Double => d + " is a double value." //匹配浮点型的值

       case "Spark"=>"Spark is found." //匹配特定的字符串

       case s: String => s + " is a string value." //匹配其它字符串

       case _ =>"unexpected value："+ elem  //与以上都不匹配

               }

               println(str)

 }
```



函数式编程

 字面量包括整数字面量、浮点数字面量、布尔型字面量、字符字面量、字符串字面量、符号字面量、==函数字面量==和元组字面量

•就像变量的“类型”和“值”是分开的两个概念一样，函数式编程中，函数的“类型”和“值”也成为两个分开的概念，函数的“值”，就是“函数字面量”

 Int => Int
==上面就得到了函数的“类型”==

 (value) => {value += 1} //只有一条语句时，大括号可以省略
 注意：==上面就是函数的“值”==，需要注意的是，采用“=>”而不是“=”，这是Scala的语法要求

 我们不需要给每个函数命名，这时就可以使用==匿名函数==，如下：
 (num: Int) => num * 2

理解下面的==下划线函数==
![](image-20250105143844124.png)

高阶函数
```
 方案二：采用高阶函数

 def powerOfTwo(x: Int): Int = {if(x == 0) 1 else 2 * powerOfTwo(x-1)}

 def sum(f: Int => Int, a: Int, b: Int):Int = {

   if(a > b) 0 else f(a) + sum(f, a+1, b)

 }

 scala> sum(x=>x,1,5) //直接传入一个匿名函数

 //且省略了参数x的类型，因为可以由sum的参数类型推断出来

 res8: Int = 15

 scala> sum(x=>x*x,1,5) //直接传入另一个匿名函数

 res9: Int = 55

 scala> sum(powerOfTwo,1,5) //传入一个已经定义好的方法

 res10: Int = 62
```


map方法会返回一个与原容器==类型大小都相同的新容器==，只不过==元素的类型可能不同==


rdd的stage划分
```
val rdd1 = sc.textFile("data.txt")       // RDD1: Stage 1
val rdd2 = rdd1.map(_.split(" "))       // RDD2: Stage 1
val rdd3 = rdd2.flatMap(x => x)         // RDD3: Stage 1
val rdd4 = rdd3.map((_, 1))             // RDD4: Stage 1
val rdd5 = rdd4.reduceByKey(_ + _)      // RDD5: Stage 2 (宽依赖)
val rdd6 = rdd5.filter(_._2 > 10)       // RDD6: Stage 2
rdd6.saveAsTextFile("output")           // Action: 触发 DAG 提交

```

>[!Note]
>flatmap的作用，将数组套数组扁平化。

### 会产生宽依赖的操作，bykey，join和union，本质是shuffle了不同分区

宽依赖的核心特点是**需要在分区之间进行 Shuffle 操作**，`reduceByKey` 是宽依赖中最常用的场景之一，但类似 `groupByKey`、`join` 和 `sortByKey` 等操作也会产生宽依赖。